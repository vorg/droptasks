<!DOCTYPE html>
<html lang="en">
<head>
<link rel="stylesheet" type="text/css" href="css/reset.css"/>
<link rel="stylesheet" type="text/css" href="css/style.css"/>
<script type="text/javascript" src="js/jquery.js"></script>
<script type="text/javascript" src="js/jquery.mustache.js"></script>
<script type="text/javascript" src="js/utils.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="text/javascript">

//var gui = require('nw.gui');
//var win = gui.Window.get();
//win.enterFullscreen();

var nodeTmpl;

var state = {
  cur: null
}

function init() {
  nodeTmpl = $("#nodeTmpl").html();
  loadTaskFile("file:///Users/vorg/Dropbox/Tasks/tasks.taskpaper");
  //loadTaskFile("/Users/vorg/Dropbox/Tasks/stuff.taskpaper");

  //Window.enterFullscreen();
}

function loadTaskFile(file) {
  $.get(file, function(data) {
    parseTaskFile(file, data);
  })
}

function createNode(text, classNames) {
  var node = $($.mustache(nodeTmpl, { text : text, className : classNames.join(" ") }));
  node.click(function() {
    selectNode(node);
  })
  //we have to add it to dom so we can measure it's size with CSS applied
  $(".columns").eq(0).append(node);
}

function addNodeAfter() {

}

function parseTaskFile(file, data) {
  var lines = data.split("\n");
  var title = file.substr(file.lastIndexOf("/")+1);
  var container = "";

  var nodesInProject = 0;
  for(var i in lines) {
    var line = lines[i].trim();
    if (line.length == 0) continue;
    if (line.trim().lastIndexOf(":") == line.length - 1) {
      var projectName = line.substr(0, line.length-1);
      createNode(projectName, ["project"]);
    }
    else {
      var classNames = [];
      var task = line;
      task = task.replace(/\s*-\s*/, "");
      task =  task.replace(/(@[^(\s]+\(*[^)]*\)*)/, "<span class='tag'>$1</span>");
      var tags = task.match(/(?:@)[a-zA-Z0-9\-]+/g)
      if (tags) classNames =  classNames.concat(tags.map(function(tag) { return tag.replace("@", "")} ));
      createNode(task, classNames);
    }
  }
}

window.addEventListener('keydown', function(e) {
  //state.edited = true;

  if (e.ctrlKey) {
    var c = String.fromCharCode(e.charCode || e.keyCode);
    switch(c) {
      //case 'S': saveData(); break;
      //case 'L': loadData(); break;
    }
    e.preventDefault();
    return;
  }

  if (state.currentNode == null) return;

  switch(e.keyCode) {
    //case 9: //Tab
    //  if (e.shiftKey) {
    //    selectParentNode(state.currentNode);
    //    editNode(state.currentNode);
    //  }
    //  else {
    //    selectNode(addChildNode(state.currentNode));
    //    editNode(state.currentNode);
    //  }
    //  e.preventDefault();
    //break;
    case 13: //Enter
      if (state.editMode) {
        exitEditNode(state.currentNode);
      }
    //  else {
    //    selectNode(addSiblingNode(state.currentNode));
    //    editNode(state.currentNode);
    //  }
    //  e.preventDefault();
      break;
    case 37: //Left
      if (!state.editMode) {
        selectNodeOnTheLeft(state.currentNode);
        e.preventDefault();
      }
     break;
    case 38: //Up
      if (!state.editMode) {
    //    if (e.metaKey) { //move up
    //      var prev = state.currentNode.prev();
    //      if (prev.size() > 0) {
    //        prev.before(state.currentNode);
    //      }
    //    }
    //    else {
            selectPrevNode(state.currentNode);
    //    }
        e.preventDefault();
      }
      break;
    case 39: //Right
      if (!state.editMode) {
        selectNodeOnTheRight(state.currentNode);
        e.preventDefault();
      }
      break;
    case 40: //Down
      if (!state.editMode) {
        //if (e.metaKey) { //move up
        //  var next = state.currentNode.next();
        //  if (next.size() > 0) {
        //    next.after(state.currentNode);
        //  }
        //}
        //else {
            selectNextNode(state.currentNode);
        //}
        e.preventDefault();
      }
      break;
    case 27: //ESC
      if (state.editMode) {
        state.currentNode.text(state.editModePrevText);
        exitEditNode(state.currentNode);
        e.preventDefault();
      }
      break;
    case 46: //DEL
      if (!state.editMode) {
        var nodeToDelete = state.currentNode;
        selectNextNode(state.currentNode);
        if (state.currentNode == nodeToDelete) selectPrevNode(state.currentNode);
        if (state.currentNode == nodeToDelete) state.currentNode = null;
        deleteNode(nodeToDelete);
        e.preventDefault();
      }
      break;
    case 113: //F2
      if (!state.editMode) {
        editNode(state.currentNode);
        e.preventDefault();
      }
      break;
  }//
});

function selectNode(node) {
  if (state.currentNode != null) {
    if (state.editMode && !state.currentNode.text().trim()) {
      state.currentNode.text("-");
      state.editMode = false;
    }
    state.currentNode.removeAttr("contenteditable");
    state.currentNode.blur();
    state.currentNode.removeClass("current");
  }
  state.currentNode = node;
  state.currentNode.addClass("current");
}

function selectPrevNode(node) {
  if (node.index() > 0) {
    selectNode(node.prev());
  }
}

function selectNextNode(node) {
  if (node.index() < node.parent().children().size() - 1) {
    selectNode(node.next());
  }
}

function selectNodeOnTheLeft(node) {
  var yPos = node.position().top;
  var sibling = node.prev();
  var columns = 0;
  var closesDistance = -1;
  var closestNode = null;
  while(sibling.size() > 0) {
    var siblingY = sibling.position().top;
    var siblingDistance = Math.abs(siblingY - yPos);
    if (siblingY == 0) {
      ++columns;
      if (columns == 2) break;
    }
    if (columns == 1 && closesDistance == -1 || siblingDistance < closesDistance) {
      closestNode = sibling;
      closesDistance = siblingDistance;
    }
    sibling = sibling.prev();
  }
  if (closestNode) {
    selectNode(closestNode);
  }
}

function selectNodeOnTheRight(node) {
  var yPos = node.position().top;
  var sibling = node.next();
  var columns = 0;
  var closesDistance = -1;
  var closestNode = null;
  while(sibling.size() > 0) {
    var siblingY = sibling.position().top;
    var siblingDistance = Math.abs(siblingY - yPos);
    if (siblingY == 0) {
      ++columns;
      if (columns >= 2) break;
    }
    if (columns == 1 && closesDistance == -1 || siblingDistance < closesDistance) {
      closestNode = sibling;
      closesDistance = siblingDistance;
    }
    sibling = sibling.next();
  }
  if (closestNode) {
    selectNode(closestNode);
  }
}

function deleteNode(deleteNode) {
  deleteNode.remove();
  reflow();
}

//TODO: editNode() remove tag spans before making node contentEditable
function editNode(node) {
  node.attr("contentEditable", "").focus();
  if (node.text() == "-") {
    node.text("");
  }
  selectElementText(node.get(0));
  state.editMode = true;
  state.editModePrevText = node.text();
}

function exitEditNode(node) {
  selectNode(state.currentNode); //cancels edit mode
  state.editMode = false;
}

$(document).ready(init);
</script>
</head>
<script type="text/tmpl" id="nodeTmpl">
  <li class="node {{className}}">{{{text}}}</li>
</script>
<body>
  <ul class="columns"></ul>
</body>
</html>